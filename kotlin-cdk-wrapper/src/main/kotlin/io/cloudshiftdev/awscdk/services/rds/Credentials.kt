@file:Suppress("RedundantVisibilityModifier","RedundantUnitReturnType","RemoveRedundantQualifierName","unused","UnusedImport","ClassName","REDUNDANT_PROJECTION","DEPRECATION")

package io.cloudshiftdev.awscdk.services.rds

import io.cloudshiftdev.awscdk.SecretValue
import io.cloudshiftdev.awscdk.common.CdkObject
import io.cloudshiftdev.awscdk.common.CdkObjectWrappers
import io.cloudshiftdev.awscdk.services.kms.IKey
import io.cloudshiftdev.awscdk.services.secretsmanager.ISecret
import io.cloudshiftdev.awscdk.services.secretsmanager.ReplicaRegion
import kotlin.Boolean
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.jvm.JvmName

/**
 * Username and password combination.
 *
 * Example:
 *
 * ```
 * // Build a data source for AppSync to access the database.
 * GraphqlApi api;
 * // Create username and password secret for DB Cluster
 * DatabaseSecret secret = DatabaseSecret.Builder.create(this, "AuroraSecret")
 * .username("clusteradmin")
 * .build();
 * // The VPC to place the cluster in
 * Vpc vpc = new Vpc(this, "AuroraVpc");
 * // Create the serverless cluster, provide all values needed to customise the database.
 * DatabaseCluster cluster = DatabaseCluster.Builder.create(this, "AuroraClusterV2")
 * .engine(DatabaseClusterEngine.auroraPostgres(AuroraPostgresClusterEngineProps.builder().version(AuroraPostgresEngineVersion.VER_15_5).build()))
 * .credentials(Map.of("username", "clusteradmin"))
 * .clusterIdentifier("db-endpoint-test")
 * .writer(ClusterInstance.serverlessV2("writer"))
 * .serverlessV2MinCapacity(2)
 * .serverlessV2MaxCapacity(10)
 * .vpc(vpc)
 * .defaultDatabaseName("demos")
 * .enableDataApi(true)
 * .build();
 * RdsDataSource rdsDS = api.addRdsDataSourceV2("rds", cluster, secret, "demos");
 * // Set up a resolver for an RDS query.
 * rdsDS.createResolver("QueryGetDemosRdsResolver", BaseResolverProps.builder()
 * .typeName("Query")
 * .fieldName("getDemosRds")
 * .requestMappingTemplate(MappingTemplate.fromString("\n  {\n    \"version\": \"2018-05-29\",\n   
 * \"statements\": [\n      \"SELECT * FROM demos\"\n    ]\n  }\n  "))
 * .responseMappingTemplate(MappingTemplate.fromString("\n   
 * $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])\n  "))
 * .build());
 * // Set up a resolver for an RDS mutation.
 * rdsDS.createResolver("MutationAddDemoRdsResolver", BaseResolverProps.builder()
 * .typeName("Mutation")
 * .fieldName("addDemoRds")
 * .requestMappingTemplate(MappingTemplate.fromString("\n  {\n    \"version\": \"2018-05-29\",\n   
 * \"statements\": [\n      \"INSERT INTO demos VALUES (:id, :version)\",\n      \"SELECT * WHERE id =
 * :id\"\n    ],\n    \"variableMap\": {\n      \":id\": $util.toJson($util.autoId()),\n     
 * \":version\": $util.toJson($ctx.args.version)\n    }\n  }\n  "))
 * .responseMappingTemplate(MappingTemplate.fromString("\n   
 * $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])\n  "))
 * .build());
 * ```
 */
public abstract class Credentials(
  cdkObject: software.amazon.awscdk.services.rds.Credentials,
) : CdkObject(cdkObject) {
  /**
   * KMS encryption key to encrypt the generated secret.
   *
   * Default: - default master key
   */
  public open fun encryptionKey(): IKey? = unwrap(this).getEncryptionKey()?.let(IKey::wrap)

  /**
   * The characters to exclude from the generated password.
   *
   * Only used if `password` has not been set.
   *
   * Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/@\"\\")
   */
  public open fun excludeCharacters(): String? = unwrap(this).getExcludeCharacters()

  /**
   * Password.
   *
   * Do not put passwords in your CDK code directly.
   *
   * Default: - a Secrets Manager generated password
   */
  public open fun password(): SecretValue? = unwrap(this).getPassword()?.let(SecretValue::wrap)

  /**
   * A list of regions where to replicate the generated secret.
   *
   * Default: - Secret is not replicated
   */
  public open fun replicaRegions(): List<ReplicaRegion> =
      unwrap(this).getReplicaRegions()?.map(ReplicaRegion::wrap) ?: emptyList()

  /**
   * Secret used to instantiate this Login.
   *
   * Default: - none
   */
  public open fun secret(): ISecret? = unwrap(this).getSecret()?.let(ISecret::wrap)

  /**
   * The name to use for the Secret if a new Secret is to be generated in SecretsManager for these
   * Credentials.
   *
   * Default: - A name is generated by CloudFormation.
   */
  public open fun secretName(): String? = unwrap(this).getSecretName()

  /**
   * Username.
   */
  public open fun username(): String = unwrap(this).getUsername()

  /**
   * Whether the username should be referenced as a string and not as a dynamic reference to the
   * username in the secret.
   *
   * Default: false
   */
  public open fun usernameAsString(): Boolean? = unwrap(this).getUsernameAsString()

  private class Wrapper(
    cdkObject: software.amazon.awscdk.services.rds.Credentials,
  ) : Credentials(cdkObject)

  public companion object {
    public fun fromGeneratedSecret(username: String): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromGeneratedSecret(username).let(Credentials::wrap)

    public fun fromGeneratedSecret(username: String, options: CredentialsBaseOptions): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromGeneratedSecret(username,
        options.let(CredentialsBaseOptions::unwrap)).let(Credentials::wrap)

    @kotlin.Suppress("INAPPLICABLE_JVM_NAME")
    @JvmName("b03868995120525e6c312c2b4db8734101eb6d27be52a57f09996a4835396e0b")
    public fun fromGeneratedSecret(username: String,
        options: CredentialsBaseOptions.Builder.() -> Unit): Credentials =
        fromGeneratedSecret(username, CredentialsBaseOptions(options))

    public fun fromPassword(username: String, password: SecretValue): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromPassword(username,
        password.let(SecretValue::unwrap)).let(Credentials::wrap)

    public fun fromSecret(secret: ISecret): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromSecret(secret.let(ISecret::unwrap)).let(Credentials::wrap)

    public fun fromSecret(secret: ISecret, username: String): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromSecret(secret.let(ISecret::unwrap),
        username).let(Credentials::wrap)

    public fun fromUsername(username: String): Credentials =
        software.amazon.awscdk.services.rds.Credentials.fromUsername(username).let(Credentials::wrap)

    public fun fromUsername(username: String, options: CredentialsFromUsernameOptions): Credentials
        = software.amazon.awscdk.services.rds.Credentials.fromUsername(username,
        options.let(CredentialsFromUsernameOptions::unwrap)).let(Credentials::wrap)

    @kotlin.Suppress("INAPPLICABLE_JVM_NAME")
    @JvmName("0119aa6b8af2cf428e8ddcf75af4780c80416d50332ca96c1ad629359abae392")
    public fun fromUsername(username: String,
        options: CredentialsFromUsernameOptions.Builder.() -> Unit): Credentials =
        fromUsername(username, CredentialsFromUsernameOptions(options))

    internal fun wrap(cdkObject: software.amazon.awscdk.services.rds.Credentials): Credentials =
        CdkObjectWrappers.wrap(cdkObject) as? Credentials ?: Wrapper(cdkObject)

    internal fun unwrap(wrapped: Credentials): software.amazon.awscdk.services.rds.Credentials =
        (wrapped as CdkObject).cdkObject as software.amazon.awscdk.services.rds.Credentials
  }
}
